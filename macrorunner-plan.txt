-> Create the API:	
	- Create as few new API methods as needed
		- batch replace, insert, delete
		- matchNext
			-* matchPrev (actually harder than I thought to make it efficient.)
			
		- indexAfter, lastIndexAfter
	
	- mitigate infinite loops (yes this happened)
		- nothing can be done about them. I will make the program print a warning if it detects the word "while\(.+\)" somewhere in the code, and how they should start up task manager and end visual studio since there is no other known way to mitgate against them. I've also added some more code to make it a little smart, like regex that removes single/multiline comments, "'` strings and /regex/ objects before doing the check, but yeah
			-* Investigate javascript new thread + pthread_kill
		
	- a way to push the output while it's running. 
		- A way to catch exceptions here would be nice. Looks like it is because the command function had completed, so the link to the debugger was non-existent so no messages could be sent
			- Inject our own versions of setTimeout, clearTimeout, setInterval, clearInterval. These will keep track of timer IDs and then in visual studio we can await till all of them are null, or can manually clear the IDs if requried.

-> write unit tests
	-* indexAfter, lastIndexAfter
	-* matchNext
	-* batch replace, insert, delete
	-* containsWhileLoop
	-* setInterval error handling
	-* setTimeout error handling

-> do manual tests, create folder for all examples (we cant unit test these easily)
	-* getEditorSelection
	-* 

-> write documentation 
	- 

Bug tracker

-* Terminals and outputs are being confused for documents











 
-------------- test macros

//macro 



// test loop
//macro 

const file = context.getFile();
context.loop(100, () => {
  file.setText(file.getText() + "a")
}, 10)



// test error logging

// macro
const x = () => {
  const arr = [1, 2]
  context.getFile(4)
  
}
x()


// GOL test

//macro

const file = context.getFile();

let board = [];
const size = 50;

for (let i = 0; i < size; i++) {
    board[i] = []
    for (let j = 0; j < size; j++) {
        board[i].push(Math.random() > 0.5 ? " " : "*");
    }
}

let board2 = [];

for (let i = 0; i < size; i++) {
    board2[i] = []
    for (let j = 0; j < size; j++) {
        board2[i].push(Math.random() > 0.5 ? " " : "*");
    }
}


const count = (x, y) => {
    const res = [
        board[y-1] && board[y-1][x-1],
        board[y-1] && board[y-1][x],
        board[y-1] && board[y-1][x+1],
        board[y][x-1],
        board[y][x+1],
        board[y+1] && board[y+1][x-1],
        board[y+1] && board[y+1][x],
        board[y+1] && board[y+1][x+1],
    ].reduce((prev, curr) => curr && curr !== ' ' ? prev + 1 : prev, 0);

    return res;
}


loop(
    (counter) => {
        let text = "";
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                let s = count(i, j);
                if (board[j][i] === " " && s === 3) {
                    board2[j][i] = s;
                } else if (board[j][i] !== " " && (s < 2 || s > 3)) {
                    board2[j][i] = " ";
                } else {
                  board2[j][i] = board[j][i];
                } 
            }
        }

        text += board.map(
            x => x.map(y => y === " " ? "  " : "<>" ).join("")
        ).join("\n");

        file.setText(text);

        [board2, board] = [board, board2];

        context.outputImmediate();
    },
    300, 100
);
        