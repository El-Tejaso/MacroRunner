-> Create the API:
	- access and modify text
		- test
	- create new text objects where we can output new stuff
		- vscode api text editor edit not possible on closed editors
			- try doing edit in the then callback
				- it worked.
	- ability to mark undo points
		- Test
	
	- Create as few new API methods as needed
		- batch replace, insert, delete
			-* unit tests
		- matchNext
			-* unit tests
			-* matchPrev
			
		- indexAfter, lastIndexAfter
			-* unit tests
	
	- mitigate infinite loops (yes this happened)
		- nothing can be done about them. I will make the program print a warning if it detects the word "while\(.+\)" somewhere in the code, and how they should start up task manager and end visual studio since there is no other known way to mitgate against them. I've also added some more code to make it a little smart, like regex that removes single/multiline comments, "'` strings and /regex/ objects before doing the check, but yeah
			-* unit tests
		-* Investigate another thread + pthread_kill
		
	- a way to push the output while it's running. 
		- A way to catch exceptions here would be nice. Looks like it is because the command function had completed, so the link to the debugger was non-existent so no messages could be sent
			- Inject our own versions of setTimeout, clearTimeout, setInterval, clearInterval. These will keep track of timer IDs and then in visual studio we can await till all of them are null, or can manually clear the IDs if requried.
			-> test
		
			
	- Some way to get the editor selected regions
		- getEditorSelection
			- test

	
	-* named output files
		-* 

-* Breakpoint debugging? could be a VS code functionality


Bug tracker

-* Terminals and outputs are being confused for documents











 
-------------- test macros

//macro 



// test loop
//macro 

const file = context.getFile();
context.loop(100, () => {
  file.setText(file.getText() + "a")
}, 10)



// test error logging

// macro
const x = () => {
  const arr = [1, 2]
  context.getFile(4)
  
}
x()


// GOL test

//macro

const file = context.getFile();

let board = [];
const size = 50;

for (let i = 0; i < size; i++) {
    board[i] = []
    for (let j = 0; j < size; j++) {
        board[i].push(Math.random() > 0.5 ? " " : "*");
    }
}

let board2 = [];

for (let i = 0; i < size; i++) {
    board2[i] = []
    for (let j = 0; j < size; j++) {
        board2[i].push(Math.random() > 0.5 ? " " : "*");
    }
}


const count = (x, y) => {
    const res = [
        board[y-1] && board[y-1][x-1],
        board[y-1] && board[y-1][x],
        board[y-1] && board[y-1][x+1],
        board[y][x-1],
        board[y][x+1],
        board[y+1] && board[y+1][x-1],
        board[y+1] && board[y+1][x],
        board[y+1] && board[y+1][x+1],
    ].reduce((prev, curr) => curr && curr !== ' ' ? prev + 1 : prev, 0);

    return res;
}


loop(
    (counter) => {
        let text = "";
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                let s = count(i, j);
                if (board[j][i] === " " && s === 3) {
                    board2[j][i] = s;
                } else if (board[j][i] !== " " && (s < 2 || s > 3)) {
                    board2[j][i] = " ";
                } else {
                  board2[j][i] = board[j][i];
                } 
            }
        }

        text += board.map(
            x => x.map(y => y === " " ? "  " : "<>" ).join("")
        ).join("\n");

        file.setText(text);

        [board2, board] = [board, board2];

        context.outputImmediate();
    },
    300, 100
);
        